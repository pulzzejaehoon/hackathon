### **[SYSTEM PROMPT] AI Agent SaaS 플랫폼 개발 PRD (v2.0)**

**1. 프로젝트 개요 (Project Overview)**

*   **프로젝트명:** AI Agent SaaS Platform (가칭)
*   **비전:** 미려하고 직관적인 UI를 통해, 사용자가 챗 인터페이스 내에서 클릭 한 번 또는 자연어 명령으로 자신의 모든 외부 서비스를 손쉽게 제어하는 '궁극의 생산성 허브'를 구축한다.
*   **핵심 아키텍처 컨셉:**
    *   **단계적 접근:**
        *   **Phase 1 (MVP):** 아름다운 UI와 '퀵 스타트 버튼'을 통해 즉각적인 가치를 제공하는 안정적인 통합 플랫폼을 구축한다. NLP는 이 단계에 포함되지 않는다.
        *   **Phase 2 (AI-Powered):** 'MCP(Major Command Processor)'라는 별도의 AI 모듈을 개발 및 통합하여, 완전한 자연어 명령 처리 기능을 구현한다.
    *   **역할 분리:**
        *   **UI Layer:** 사용자 상호작용(버튼 클릭, 텍스트 입력)을 담당하며, 이를 '정형화된 명령어(Structured Command)'로 변환한다.
        *   **Interactor:** UI 또는 MCP로부터 '정형화된 명령어'를 받아, 실제 외부 서비스 API 호출(인증, 실행)을 담당하는 기술적 실행 계층.
        *   **MCP (Phase 2):** 사용자의 자연어 입력을 '정형화된 명령어'로 번역하는 지능형 처리 계층.

**2. 사용자 페르소나 (User Persona)**

*   (이전 버전과 동일) 바쁜 프로덕트 매니저 '알렉스'. 여러 툴을 전환하는 피로감을 느끼며, 한 곳에서 모든 것을 제어하고 싶어함.

**3. 핵심 기능 명세 (Core Feature Specifications)**

**3.1. 핵심 챗 인터페이스 (Core Chat Interface) - Phase 1**

*   **목표:** 사용자가 가장 빈번하게 사용할 작업을 즉시 실행할 수 있도록 돕는, 직관적이고 유용한 시작점을 제공한다.
*   **주요 구성 요소:**
    *   **대화창:** 시스템 피드백(예: "캘린더에 '주간 회의' 일정을 추가했습니다.")이 표시되는 영역.
    *   **명령어 입력창:** 텍스트 입력을 위한 창. Phase 1에서는 주로 피드백 확인용으로 사용되며, Phase 2에서 자연어 입력의 핵심이 된다.
    *   **퀵 스타트 버튼 (Quick Start Buttons):**
        *   **정의:** 사용자가 연결한 서비스에서 가장 자주 사용될 만한 기능들을 미리 정의해놓은 버튼 모음.
        *   **동적 생성:** 이 버튼들은 사용자가 'Integrations Hub'에서 **연결한 서비스에 따라서만 동적으로 표시**되어야 한다. (예: Gmail을 연결하지 않은 사용자에게 '최근 이메일 확인' 버튼은 보이지 않음).
        *   **예시 버튼:**
            *   `[+ 빠른 이벤트 생성]`
            *   `[✉️ 최근 이메일 5개 보기]`
            *   `[🔍 드라이브에서 '기획서' 검색]`
            *   `[💬 Slack #general 채널에 메시지 보내기]`
        *   **동작:** 각 버튼은 클릭 시, 미리 정의된 **'정형화된 명령어'** JSON 객체를 생성하여 `Interactor`에게 전달한다.

**3.2. 통합 및 실행 계층 (The "Interactor")**

*   **목표:** 외부 서비스와의 모든 기술적 상호작용(인증, API 호출)을 표준화하고, 안전하게 관리하는 백엔드 핵심 모듈. **이 모듈은 NLP/AI 기능을 전혀 포함하지 않는다.**
*   **입력:** '정형화된 명령어' (Structured Command) JSON 객체. 이 형식은 모든 기능 호출에 일관되게 사용되어야 한다.
    ```json
    {
      "service": "google.calendar",
      "action": "create_event",
      "params": {
        "title": "디자인 팀 주간 싱크업",
        "duration_minutes": 50,
        "attendees": ["designer1@example.com", "designer2@example.com"]
      },
      "userId": "user-alex-12345"
    }
    ```
*   **기능:**
    1.  **명령어 수신:** UI(퀵 스타트 버튼) 또는 MCP(Phase 2)로부터 '정형화된 명령어'를 받는다.
    2.  **인증 정보 조회:** 명령어의 `userId`와 `service`를 기반으로 DB에서 해당 사용자의 유효한 `access_token`을 조회한다. 토큰이 만료되었다면 `refresh_token`을 사용해 자동으로 갱신하고 DB에 저장해야 한다.
    3.  **API 호출 실행:** 해당 서비스의 커넥터(`routes/connectors/*.ts`)에 정의된 함수를 `params`와 함께 호출하여 실제 API 요청(cURL과 유사한 역할)을 실행한다.
    4.  **결과 반환:** API 호출의 성공/실패 결과와 데이터를 다시 호출 측(UI)에 반환한다.
*   **구현 위치:** `server/src/lib/interactor.ts`

**3.3. 명령어 처리 엔진 (The "MCP" - Major Command Processor) - Phase 2**

*   **목표:** 사용자의 자연어 입력을 Interactor가 이해할 수 있는 '정형화된 명령어'로 변환하는 AI 두뇌.
*   **프로세스:**
    1.  **자연어 입력 수신:** "내일 오후 3시에 디자인팀이랑 50분짜리 주간 싱크업 미팅 잡아줘"
    2.  **LLM을 이용한 번역:** (별도의 프롬프트 엔지니어링 필요) LLM을 호출하여 이 문장을 위에서 정의한 '정형화된 명령어' JSON 객체로 변환한다.
    3.  **Interactor에 전달:** 생성된 JSON 객체를 Interactor에 전달하여 실행을 요청한다.

**4. UI/UX 디자인 시스템 (UI/UX Design System)**

*   **목표:** 복잡한 기능을 단순하고 우아하게 표현하여, 사용자가 즉시 사용법을 익히고 편안함을 느끼게 하는 '최고 수준의 사용자 경험'을 제공한다.
*   **핵심 원칙:**
    *   **명료성 (Clarity):** 모든 요소는 명확한 목적을 가져야 한다. 불필요한 장식은 배제한다.
    *   **효율성 (Efficiency):** 사용자가 최소한의 클릭과 입력으로 작업을 완료할 수 있어야 한다.
    *   **일관성 (Consistency):** 앱 전체에 걸쳐 디자인 언어(색상, 폰트, 간격, 컴포넌트 스타일)가 일관되어야 한다.
    *   **미학 (Aesthetics):** 전문적이고 신뢰감을 주는 미니멀리즘 미학을 추구한다.
*   **스타일 가이드:**
    *   **레이아웃:** 3단 구조 (좌측: 네비게이션 바, 중앙: 핵심 챗 인터페이스, 우측: Integrations Hub). 각 패널의 너비는 조절 가능하도록 한다.
    *   **색상 팔레트:**
        *   **Primary Dark:** `#1A1A1D` (배경)
        *   **Secondary Dark:** `#2C2C34` (카드, 입력창 배경)
        *   **Accent Color:** `#4A90E2` (버튼, 링크, 하이라이트)
        *   **Text Primary:** `#F5F5F7` (주요 텍스트)
        *   **Text Secondary:** `#A9A9B3` (보조 텍스트, 아이콘)
        *   **Success:** `#34C759` (성공 피드백), **Error:** `#FF3B30` (에러 피드백)
    *   **타이포그래피:** `Inter` 또는 `Pretendard`와 같은 현대적인 Sans-serif 폰트를 사용. 명확한 위계를 위해 Font-weight와 size를 체계적으로 관리.
    *   **컴포넌트 디자인:**
        *   **챗 버블:** 부드러운 `border-radius`를 적용하고, 시스템 메시지와 사용자 입력을 명확히 구분.
        *   **입력창:** `Secondary Dark` 배경에 `Accent Color`로 포커스 상태를 표시.
        *   **퀵 스타트 버튼:** `Secondary Dark` 배경에 `Text Primary` 텍스트. 미묘한 호버(hover) 시 밝기 변화 애니메이션을 추가하여 상호작용성을 높인다.
        *   **통합 허브 카드:** 각 서비스 로고, 서비스명, 연결 상태('Connected'/'Disconnected')를 명확한 아이콘과 텍스트로 표시. 'Connected' 상태일 때는 `Accent Color`로 테두리나 아이콘에 포인트를 준다.
        *   **모달(Modals):** 설정이나 중요한 확인 창은 뒷배경을 어둡게 처리(dim)하여 집중도를 높인다.

**5. 개발 로드맵 (Development Roadmap)**

*   **Phase 1: 안정적인 MVP 구축 (Focus: UI/UX & Core Functionality)**
    1.  **UI/UX 기반 구축:** 제시된 디자인 시스템에 따라 React 컴포넌트(레이아웃, 색상, 폰트, 카드, 버튼 등)의 기본 스타일을 전면적으로 재작업한다.
    2.  **Interactor 구현:** '정형화된 명령어'를 받아 처리하는 `interactor.ts`의 핵심 로직을 완성한다.
    3.  **Google Calendar & Gmail 연동:** 두 서비스에 대한 OAuth 2.0 인증 흐름과 토큰 관리(DB 저장/갱신)를 완벽하게 구현한다. `connectors`의 API 호출 함수들을 작성한다.
    4.  **퀵 스타트 버튼 구현:** Google Calendar/Gmail이 연결되었을 때만 관련 퀵 스타트 버튼이 나타나도록 하고, 클릭 시 `Interactor`를 호출하여 기능이 동작하도록 E2E(End-to-End)로 구현한다.
    5.  **피드백 시스템:** `Interactor`의 실행 결과를 챗 버블을 통해 사용자에게 명확하게 표시한다.

*   **Phase 2: AI 기능 통합 (Focus: NLP)**
    1.  **MCP 모듈 설계/개발:** LLM을 활용하여 자연어를 '정형화된 명령어' JSON으로 변환하는 `MCP` 모듈을 개발한다.
    2.  **챗 인터페이스 통합:** 명령어 입력창에 입력된 자연어를 `MCP`로 보내고, 반환된 '정형화된 명령어'를 `Interactor`에 전달하는 흐름을 구현한다.
    3.  **컨텍스트 관리:** 대화의 맥락을 기억하여 "거기에 참석자 한 명 더 추가해줘"와 같은 후속 명령을 처리할 수 있는 기능을 점진적으로 추가한다.